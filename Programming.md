# Programming

A programmer should know [lots](http://programmer.97things.oreilly.com/wiki/index.php/Contributions_Appearing_in_the_Book) [of](http://www.artima.com/weblogs/viewpost.jsp?thread=331531) [concepts](http://programmer.97things.oreilly.com/wiki/index.php/Other_Edited_Contributions). Try to keep in mind the following principles:

- **Small is beautiful**.
  - Small things have tremendous advantages over their larger counterparts. Among these is the ability to combine with other small things in unique and useful ways.
  - The more you can decompose, the more innovation you'll drive.
  - The best code is no code, or code you don't have to maintain.
- **Design for simplicity**.
  - Do the [simplest thing that could possibly work](https://www.seangoedecke.com/the-simplest-thing-that-could-possibly-work/). Start with the absolute minimum viable implementation and only add complexity when new requirements absolutely demand it (e.g: UNIX tools remain incredibly powerful and efficient for "Big Data").
  - Good system design looks "boring". Impressive complexity often signals over-design. Start simple and evolve.
  - Benefits of simplicity: ease of understanding, ease of change (improvement), ease of debugging, flexibility. [The goal of software design is to create chunks or slices that fit into a human mind](https://mobile.twitter.com/KentBeck/status/1354418068869398538). The software keeps growing but the human mind maxes out, so we have to keep chunking and slicing differently if we want to keep making changes.
  - We are simple apes and we like simple stone tools.
  - Break down complex problems into simpler, digestible pieces. If you do it right, it will feel like cheating: you just solve simple problems until you're done.
  - We can't change our brain to grasp something complex. We need to simplify complexity so we can handle it.
  - Simplicity means fewer moving pieces, less internal connectivity, and components with clear, straightforward interfaces that remain stable without ongoing maintenance.
  - Simple doesn't mean hacky or low-quality. The first solution is rarely the simplest - simplicity requires deep understanding of the current system.
  - Eliminate state. If you can't, make it visible. Stateful components can get into a bad state.
    - Have one service that knows about the state - i.e. it talks to a database - [and other services that do stateless things](https://www.seangoedecke.com/good-system-design/).
  - Design is an iterative process. The necessary number of iterations is one more than the number you have currently done. This is true at any point in time.
  - Complexity is the single major difficulty in the successful development of large-scale software systems.
  - [You don't need to scale right away](https://thmsmlr.com/cheap-infra). Servers are getting more capable faster than the internet is growing. Anticipating future scale is often counterproductive - most systems can't accurately predict multi-order-of-magnitude growth.
  - Compounding complexity must be fought at every turn. [Alternate between phases of expansion (new features) and consolidation](https://qntm.org/devphilo).
  - Write code that's easy to delete.
  - If you can't easily explain why something is difficult, then it's incidental complexity, which is probably worth addressing.
  - Reuse [patterns](https://www.digitalocean.com/community/tutorials/gangs-of-four-gof-design-patterns).
  - The number of moving pieces on average doubles every 18-24 months. No one fully understands [[Systems]].
  - [There are different notions of simplicity](https://vitalik.eth.limo/general/2018/11/25/central_planning.html) (Kolmogorov complexity vs VC Dimension). What is "simple" to describe or appears to have few knobs in one language for describing it is devilishly complex in another, and vice versa.
  - Most performance wins come from removing work, not adding cleverness.
  - [Good taste is writing code that looks so simple, everyone else says "anyone could have written that!"](https://news.ycombinator.com/item?id=45411143)
- **Do one thing and do it well**.
  - By focusing on a single task, a program or function can eliminate much extraneous code that often results in excess overhead, unnecessary complexity, and a lack of flexibility. [Good software makes hard things easy](https://medium.com/s/story/notes-to-myself-on-software-engineering-c890f16f4e4d).
  - Design composable primitives. Name things simply and clearly.
- [**Make it work, make it right, make it fast**](https://wiki.c2.com/?MakeItWorkMakeItRightMakeItFast).
  - Build a prototype as soon as possible to get a sense of the entire process.
  - Once you have a working prototype, apply guidelines and previous learnings. Then, focus on performance.
  - There is nothing so useless as doing efficiently that which should not be done at all.
  - Writing program code is a good way of debugging your thinking.
  - [You can edit a bad page, but you can't edit a blank one.](https://addyosmani.com/blog/21-lessons/)
  - Apply small improvements at each iteration. Running the program will make it more resilient and robust as more errors get fixed.
  - Premature optimization is the root of all evil. Abstraction is a form of optimization and shouldn't be done before the space has been properly explored to know what abstractions should be built. Standardization is a form of optimization and shouldn't be proposed until there's a body of evidence to support what's being standardized.
    - [Increased efficiency can sometimes, counterintuitively, lead to worse outcomes](https://sohl-dickstein.github.io/2022/11/06/strong-Goodhart.html).
    - You should be able to "punch through" your abstraction layer and get to the code behind it in cases you need that.
  - Sometimes you have to stop sharpening the saw, and just start cutting.
  - Software which is broken because there is no incentive to ship good software is going to stay broken until the incentives change.
  - [Software that's fast changes behavior](https://www.catherinejue.com/fast). Fast eliminates cognitive friction and signals simplicity.
- **Choose portability over efficiency**.
  - If today's hardware just about runs a program with just about adequate efficiency, tomorrow's will run it with power to spare.
  - The developer task is to make sure his program will run on that new hardware with minimal effort.
- **Data is only useful as long as it's being used**.
  - Flat files help ensure that data is usable for the longest possible time.
  - For complex data structures where plain text really isn't appropriate, use a structured text format instead. If you've chosen the right data structures and organized things well, the algorithms will almost always be self-evident. [Data structures, not algorithms, are central to programming](https://users.ece.utexas.edu/~adnan/pike.html).
- **A programmer who can't reuse other programs is condemned to re-write them**.
  - Use software leverage to your advantage.
  - Many programmers have only a superficial understanding of the importance of reusable code modules.
  - [Code isn't just meant to be executed. Code is also a means of [[Communication]] across a team, a way to describe to others the solution to a problem](https://medium.com/s/story/notes-to-myself-on-software-engineering-c890f16f4e4d). Good writing skills often correlate with good thinking and programming skills. [Sharing knowledge through writing (blogs, talks, documentation, open source) clarifies your thinking and helps others](https://endler.dev/2025/best-programmers/).
- **Silence is golden**.
  - A silent command is often more usable, providing the function asked for and nothing more.
- **Think parallel**.
  - Most tasks are composed of sub-tasks which may be attacked in parallel. This also applies to user interactions.
  - Parallelism can save a great deal of time and frustration.
- **The sum of the parts is greater than the whole**.
  - A large application built from a collection of smaller programs is more flexible and hence more useful than a single large program.
  - The same functional capability may exist in both solutions, but the collection-of-small-programs approach is the more forward-looking of the two.
- [The computer is a machine, but a codebase is an organism](http://web.archive.org/web/20240525224151/https://meltingasphalt.com/a-codebase-is-an-organism/). The organic nature of code manifests itself in the dual forces of growth and decay. It also suggests that you should know your code smells. These smells won't be causing problems during execution, on the machine. Instead, it's going to cause problems during [[Evolution]] of the codebase.
- **Look for the 80% solution**.
  - Doing 100% of anything is difficult. [Don't focus on perfection](https://youtu.be/pYIho556BS8).
  - Focusing in the 80% is far more efficient and cost-effective. "Better" is the enemy of "good".
  - Handle the 80% and let the 20% fend for themselves.
  - [[Pareto Principle|80% of the impact comes from 20% of the work]]. If shitty code solves the problem, it's not shitty code.
  - [Software is never finished, only abandoned](https://stackoverflow.blog/2020/02/20/requirements-volatility-is-the-core-problem-of-software-engineering/).
- **Treat all the data as an [append only event log](https://www.youtube.com/watch?v=ZQ-MdKj3BjU)**.
  - Use a central log where consumers can subscribe to the relevant events.
  - Having a central place ([the log](https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying)) for continuous events make easy to create a stream of data to process and sets a source of truth.
  - A [log improves coordination in distributed systems](https://restate.dev/blog/every-system-is-a-log-avoiding-coordination-in-distributed-applications/).
- **[Reduce cognitive load](https://minds.md/zakirullin/cognitive)**.
  - Working memory is tiny (≈4 chunks). Design code, tests, and APIs so a change fits in one mental model at a time.
  - Prefer deep modules. Simple, stable interfaces that hide complexity. Avoid fleets of tiny wrappers and over‑factored classes/methods.
  - Limit choice. Favor a small, orthogonal subset of language/library features over clever, "feature‑rich" constructs.
- **There is no silver bullet**.
  - Accept that many programming decisions are opinions.
  - Make the trade-offs explicit when making judgments and decisions. With almost every decision you make, you're either deliberately or accidentally trading off one thing for another thing.
  - Discuss [trade-offs](https://twitter.com/kelseyhightower/status/774076482637312001), which you prefer, and reach a resolution.
  - [Every system eventually sucks](https://www.simplethread.com/20-things-ive-learned-in-my-20-years-as-a-software-engineer/). Assume everything has bugs.
  - [It's difficult (if not impossible) to design systems that have perfect consistency, perfect availability, incredibly low latency, and incredibly high throughput, all at the same time](https://jazco.dev/2025/02/19/imperfection/).
  - Have [sensible defaults](https://koaning.io/posts/sensible-defaults/).
- **Keep the [[Feedback Loops|iteration loop]] short**.
  - Invest in tools to [[Automation|automate]] and improve the development cycle (CI, CD). Decreasing build times a few seconds actually saves a lot of time over time. Deploy often to make the loop end to end. If you need to do something manually more than twice, then write a tool for the third time.
- **Avoid implicit rules**.
  - Implicit rules should always be made explicit and shared with others or automated. Ideally, all processes should be written as code, stored, and versioned. Minimize the cognitive load imposed on your users.
  - The best way to understand something is to break it. The second best way is to rewrite it from scratch without using any external libraries.
- **Make APIs boring**.
  - [Designing APIs is a balance between familiarity and flexibility](https://www.seangoedecke.com/good-api-design/).
  - Don't break userspace.
  - The success of an API depends entirely on the product or service it enables.
  - Your API should support simple API keys for authentication, because many of your users will not be professional engineers.
  - Requests that take action (particularly high-stakes action like payments) should include some kind of idempotency key to make retries safe.
  - Your API will always be a source of incidents. Make sure you have rate limits and killswitches in place.

Like any other field, the world of Software Development has some interesting and famous "laws". These are some of them I've found interesting, funny or worth knowing:

- [Laws of Software Development](http://www.globalnerdy.com/2007/07/18/laws-of-software-development/)
- [Famous Laws Of Software Development](https://www.timsommer.be/famous-laws-of-software-development/)
- [Laws of Computing](https://gist.github.com/sorahn/905f67acf00d6f2aa69e74a39de65941)
- [Hacker Laws](https://github.com/dwmkerr/hacker-laws) ([website](https://hacker-laws.com/))
- [Engineering Axioms](https://martinrue.com/my-engineering-axioms/)
- [CUPID](https://dannorth.net/2022/02/10/cupid-for-joyful-coding/)
- [Things they didn't teach you about Software Engineering](https://vadimkravcenko.com/shorts/things-they-didnt-teach-you/)
- [Amdahl to Zipf: Ten Laws of the Physics of People](http://hintjens.com/blog:100)

## Resources

- [Semantic Versioning](https://semver.org/)
- [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)
- [Documentation Guide](https://www.writethedocs.org/guide/#)
- [Formatting your README](https://guides.github.com/features/wikis/#Formatting-a-readme)
- [Open Source Guides](https://opensource.guide/)
- [Github Badges](https://shields.io/)
- [Icons and Photos For Everything](https://thenounproject.com/), [other illustrations](https://github.com/sw-yx/spark-joy#illustrations) and [color toolbox](https://hue.tools/).
- [Command Line Interface Guidelines](https://clig.dev/) and [12 factors CLI apps](https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46) and [Learnings after building CLI apps](https://simonwillison.net/2023/Sep/30/cli-tools-python/).
